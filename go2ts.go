// Package go2ts is an extremely simple and powerful Go to Typescript generator.
// It can handle all JSON serializable Go types and also has the ability to
// define TypeScript union types for your enum-like types.
package go2ts

import (
	"fmt"
	"go/ast"
	"html/template"
	"io"
	"reflect"
	"strings"
)

// Go2TS writes TypeScript definitions for Go types.
type Go2TS struct {
	interfaces []interfaceDefinition
	types      []typeDefinition

	// interfacesSeen maps reflect.Types to the name of their interface definition.
	interfacesSeen map[reflect.Type]string

	// typesSeen maps TypeScript type definition names that have already been added.
	typesSeen map[string]bool

	// anonymousCount keeps track of the number of anonymous structs we've had to name.
	anonymousCount int
}

// New returns a new *Go2TS.
func New() *Go2TS {
	ret := &Go2TS{
		typesSeen:      map[string]bool{},
		interfacesSeen: map[reflect.Type]string{},
	}
	return ret
}

// Add a type that needs a TypeScript definition.
//
// See AddWithName() for more details.
func (g *Go2TS) Add(v interface{}) error {
	return g.AddWithName(v, "")
}

// AddWithName adds a type that needs a TypeScript definition.
//
// The value passed in can be an instance of a type, a reflect.Type, or a
// reflect.Value.
//
// The 'name' supplied will be the TypeScript interface name. If 'interfaceName'
// is the empty string then the Go type name will be used. If the type is of a
// struct that is anonymous it will be given a name of the form "AnonymousN".
//
// If the type is a struct, the fields of the struct will be named following the
// convention for json serialization, including using the json tag if supplied.
// Fields tagged with `json:",omitempty"` will have "| null" added to their
// type.
//
// There is special handling of time.Time types to be TypeScript "string"s since
// time.Time implements MarshalJSON, see
// https://pkg.go.dev/time?tab=doc#Time.MarshalJSON.
func (g *Go2TS) AddWithName(v interface{}, interfaceName string) error {
	var reflectType reflect.Type
	switch v := v.(type) {
	case reflect.Type:
		reflectType = v
	case reflect.Value:
		reflectType = v.Type()
	default:
		reflectType = reflect.TypeOf(v)
	}

	_, err := g.addType(reflectType, interfaceName)
	return err
}

// AddUnion adds a TypeScript definition for a union type of the values in 'v',
// which must be a slice or an array.
func (g *Go2TS) AddUnion(v interface{}) error {
	return g.AddUnionWithName(v, "")
}

// AddUnionWithName adds a TypeScript definition for a union type of the values
// in 'v', which must be a slice or an array.
//
// If typeName is the empty string then the name of type of elements in the
// slice or array is used as the type name, otherwise the typeName supplied will
// be used as the TypeScript type name.
//
func (g *Go2TS) AddUnionWithName(v interface{}, typeName string) error {
	typ := reflect.TypeOf(v)
	kind := typ.Kind()
	if kind != reflect.Slice && kind != reflect.Array {
		return fmt.Errorf("AddUnionWithName must be supplied an array or slice, got %v: %v", kind, v)
	}
	if typeName == "" {
		typeName = typ.Elem().Name()
	}
	values := reflect.ValueOf(v)
	valuesAsStrings := make([]string, values.Len())
	for i := range valuesAsStrings {
		value := values.Index(i)
		if value.Kind() == reflect.String {
			valuesAsStrings[i] = fmt.Sprintf("%q", values.Index(i).Interface())
		} else {
			valuesAsStrings[i] = fmt.Sprintf("%v", values.Index(i).Interface())
		}
	}
	unionDefinition := strings.Join(valuesAsStrings, " | ")
	td := typeDefinition{
		name: typeName,
		tsType: &tsType{
			typeName: unionDefinition,
		},
	}
	if g.typesSeen[typeName] {
		// A union type is always going to be more specific than the type
		// definition found when building an interface, so overwrite the
		// existing definition.
		for i, t := range g.types {
			if t.name == typeName {
				g.types[i] = td
			}
		}
		return nil
	}
	g.typesSeen[typeName] = true
	g.types = append(g.types, td)
	return nil
}

// Render the TypeScript definitions to the given io.Writer.
func (g *Go2TS) Render(w io.Writer) error {
	_, err := fmt.Fprintln(w, "// DO NOT EDIT. This file is automatically generated.")
	if err != nil {
		return err
	}
	for _, intf := range g.interfaces {
		if err := intf.render(w); err != nil {
			return err
		}
	}

	for _, typ := range g.types {
		if _, err := fmt.Fprintln(w, typ.String()); err != nil {
			return err
		}
	}

	return nil
}

// primitive is the list of Kinds that we support converting to TypeScript.
var primitive = map[reflect.Kind]bool{
	reflect.Bool:    true,
	reflect.Int:     true,
	reflect.Int8:    true,
	reflect.Int16:   true,
	reflect.Int32:   true,
	reflect.Int64:   true,
	reflect.Uint:    true,
	reflect.Uint8:   true,
	reflect.Uint16:  true,
	reflect.Uint32:  true,
	reflect.Uint64:  true,
	reflect.Uintptr: true,
	reflect.Float32: true,
	reflect.Float64: true,
	reflect.String:  true,
}

func isPrimitive(kind reflect.Kind) bool {
	return primitive[kind]
}

func (g *Go2TS) tsTypeFromReflectType(reflectType reflect.Type, calledFromAddType bool) *tsType {
	var ret tsType
	kind := reflectType.Kind()
	if kind == reflect.Ptr {
		ret.canBeNull = true
		reflectType = removeIndirection(reflectType)
		kind = reflectType.Kind()
	}

	// As we build up the chain of tsTypes that fully describes a typeDefinition
	// we may come across named types. For example: map[string]Donut, where
	// Donut could be a "type Donut struct {...}", or a type based on a
	// primitive type, such as "type Donut string". In this case we need to add
	// that type to all of our known types and return a reference to that type
	// from here.
	if !calledFromAddType && // Don't do this if called from addType().
		reflectType.Name() != "" && // Don't bother with anonymous structs.
		!isTime(reflectType) && // Also skip time.Time.
		(!isPrimitive(reflectType.Kind()) || // And either it's not a primitive Kind.
			// Or it's case where a primitive Kind like string shows up with a type name.
			(isPrimitive(reflectType.Kind()) && reflectType.Name() != reflectType.Kind().String())) {
		typeName, err := g.addType(reflectType, "")
		if err == nil {
			return &tsType{
				typeName:  typeName,
				canBeNull: ret.canBeNull,
			}
		}
	}

	// Default to using the Go lang type name as the TypeScript type name.
	nativeType := reflectType.String()

	// Strip off the module name of the native type if present.
	if i := strings.IndexByte(nativeType, '.'); i > -1 {
		nativeType = nativeType[i+1:]
	}
	ret.typeName = nativeType

	switch kind {
	case reflect.Uint8,
		reflect.Uint16,
		reflect.Uint32,
		reflect.Uint64,
		reflect.Uint,
		reflect.Int8,
		reflect.Int16,
		reflect.Int32,
		reflect.Int64,
		reflect.Int,
		reflect.Float32,
		reflect.Float64:
		ret.typeName = "number"

	case reflect.String:
		ret.typeName = "string"

	case reflect.Bool:
		ret.typeName = "boolean"

	case reflect.Map:
		ret.typeName = "map"
		ret.keyType = g.tsTypeFromReflectType(reflectType.Key(), false)
		ret.subType = g.tsTypeFromReflectType(reflectType.Elem(), false)

	case reflect.Slice, reflect.Array:
		ret.typeName = "array"
		ret.canBeNull = (kind == reflect.Slice)
		ret.subType = g.tsTypeFromReflectType(reflectType.Elem(), false)

	case reflect.Struct:
		if isTime(reflectType) {
			ret.typeName = "string"
		} else {
			ret.typeName = "interface"
			name, _ := g.addType(reflectType, "")
			ret.interfaceName = name
		}

	case reflect.Interface:
		ret.typeName = "any"

	case reflect.Complex64,
		reflect.Complex128,
		reflect.Chan,
		reflect.Func,
		reflect.UnsafePointer:
		panic(fmt.Sprintf("Go Kind %q cannot be serialized to JSON.", kind))
	}
	return &ret
}

// addInterfaceFields populates the fields of the given interfaceDefinition. It
// assumes reflectType's Kind is Struct.
func (g *Go2TS) addInterfaceFields(id *interfaceDefinition, reflectType reflect.Type) {
	for i := 0; i < reflectType.NumField(); i++ {
		structField := reflectType.Field(i)

		// Skip unexported fields.
		if len(structField.Name) == 0 || !ast.IsExported(structField.Name) {
			continue
		}

		field := newFieldDefinition(structField)
		field.tsType = g.tsTypeFromReflectType(structField.Type, false)
		id.Fields = append(id.Fields, field)
	}
}

func (g *Go2TS) getAnonymousInterfaceName() string {
	g.anonymousCount++
	return fmt.Sprintf("Anonymous%d", g.anonymousCount)
}

func (g *Go2TS) addType(reflectType reflect.Type, interfaceName string) (string, error) {
	reflectType = removeIndirection(reflectType)
	if tsTypeName, ok := g.interfacesSeen[reflectType]; ok {
		return tsTypeName, nil
	}
	if reflectType.Kind() == reflect.Struct {
		if interfaceName == "" {
			interfaceName = strings.Title(reflectType.Name())
		}
		if interfaceName == "" {
			interfaceName = g.getAnonymousInterfaceName()
		}

		intf := interfaceDefinition{
			Name:   interfaceName,
			Fields: make([]fieldDefinition, 0, reflectType.NumField()),
		}

		g.interfacesSeen[reflectType] = intf.Name
		g.addInterfaceFields(&intf, reflectType)
		g.interfaces = append(g.interfaces, intf)
		return intf.Name, nil
	}

	// Handle non-struct types.
	typeDefinition := newTypeDefinition(reflectType)
	if interfaceName != "" {
		typeDefinition.name = interfaceName
	}
	typeDefinition.tsType = g.tsTypeFromReflectType(reflectType, true)
	if g.typesSeen[typeDefinition.name] {
		return typeDefinition.name, nil
	}
	g.typesSeen[typeDefinition.name] = true
	g.types = append(g.types, typeDefinition)
	return typeDefinition.name, nil
}

// tsType represents either a type of a field, like "string", or part of
// a more complex type like the map[string] part of map[string]time.Time.
type tsType struct {
	// typeName is the TypeScript type, such as "string", or "map", or "SomeInterfaceName".
	typeName string

	// keyType is the type of the key if this tsType is a map.
	keyType *tsType

	// interfaceName is the name of the TypeScript interface if the tsType is
	// "interface".
	interfaceName string

	canBeNull bool
	subType   *tsType
}

// String returns the tsType formatted as TypeScript.
func (s tsType) String() string {
	var ret string
	switch s.typeName {
	case "array":
		ret = s.subType.String() + "[]"
	case "map":
		ret = fmt.Sprintf("{ [key: %s]: %s }", s.keyType.String(), s.subType.String())
	case "interface":
		ret = s.interfaceName
	default:
		ret = s.typeName
	}

	return ret
}

// typeDefinition represents a TypeScript type definition.
type typeDefinition struct {
	name   string
	tsType *tsType
}

func (t typeDefinition) String() string {
	return fmt.Sprintf("\nexport type %s = %s;", t.name, t.tsType.String())
}

// newTypeDefinition creates a new typeDefinition from the given reflect.Type.
func newTypeDefinition(reflectType reflect.Type) typeDefinition {
	return typeDefinition{
		name: reflectType.Name(),
	}
}

// fieldDefinition represents one field in an interface.
type fieldDefinition struct {
	// The name of the interface field.
	name       string
	tsType     *tsType
	isOptional bool
}

func (f fieldDefinition) String() string {
	optional := ""
	if f.isOptional {
		optional = "?"
	}

	canBeNull := ""
	if f.tsType.canBeNull {
		canBeNull = " | null"
	}

	return fmt.Sprintf("\t%s%s: %s%s;", f.name, optional, f.tsType.String(), canBeNull)
}

// newFieldDefinition creates a new fieldDefinition from the given reflect.StructField.
func newFieldDefinition(structField reflect.StructField) fieldDefinition {
	var ret fieldDefinition
	jsonTag := strings.Split(structField.Tag.Get("json"), ",")

	ret.name = structField.Name
	if len(jsonTag) > 0 && jsonTag[0] != "" {
		ret.name = jsonTag[0]
	}
	ret.isOptional = len(jsonTag) > 1 && jsonTag[1] == "omitempty"
	return ret
}

func isTime(t reflect.Type) bool {
	return t.Name() == "Time" && t.PkgPath() == "time"
}

// interfaceDefinition represents a single Go struct that gets emitted as a
// TypeScript interface.
type interfaceDefinition struct {
	// Name is the TypeScript interface Name in the generated output.
	Name   string
	Fields []fieldDefinition
}

var interfaceDefinitionTemplate = template.Must(template.New("").Parse(`
export interface {{ .Name }} {
{{ range .Fields -}}
	{{- . }}
{{ end -}}
}
`))

func (s *interfaceDefinition) render(w io.Writer) error {
	return interfaceDefinitionTemplate.Execute(w, s)
}

func removeIndirection(reflectType reflect.Type) reflect.Type {
	kind := reflectType.Kind()
	// Follow all the pointers until we get to a non-Ptr kind.
	for kind == reflect.Ptr {
		reflectType = reflectType.Elem()
		kind = reflectType.Kind()
	}
	return reflectType
}
